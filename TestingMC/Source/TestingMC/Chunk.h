// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "EGroundTypes.h"
#include "Components/InstancedStaticMeshComponent.h"
#include "Chunk.generated.h"

class AChunkSpawner;
class FastNoiseLite;

UCLASS()
class TESTINGMC_API AChunk : public AActor
{
	GENERATED_BODY()

public:
	AChunk();

	//function for setting seed for surface noise generation
	//called from blueprint UI widget
	UFUNCTION(BlueprintCallable)
	void SetSeed(int NewSeed);

	//compute each index for 3D matrix representing terrain type for each cube in chunk
	void GenerateTerrain();

	//clear all instances of ISM component
	void UninitializeChunk();

	//add instance with appropriate SM and texture to each cube generated in chunk
	//instances are not added as cube SM, but as 2D planes and only planes next to the "air" cube are drawn
	void DrawTerrain();

	//try to remove cube player is aiming at
	//input is 3D point lying inside that cube
	void RemoveCube(const FVector& PointInCube);

	//try to add cube on place player is aiming at
	//input is 3D point lying inside that cube
	void AddCube(const FVector& PointInside);

	//returns position of one cube in chunk in arbitrary coordinates systems for cubes
	FIntVector GetPositionIndices(const FVector& Position);

	//getter for ISM component
	UInstancedStaticMeshComponent* GetInstancedMesh();

	//this actor coordinates in arbitrary chunk system
	UPROPERTY()
	FVector MyCoords;

	//marks if this chunk is currently used, thus have ISM with instances
	bool IsUsed;

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

	//decides which type of ground/texture will be at particular position based on z height
	//param TopCube: highest cube of ground generated by noise for particular x, y coords
	//x, y, z are input values are cube coordinates represented by indices in 3Darray,
	void SetGroundValue(int x, int y, int z, int TopCube);

	//generate 3D noise for cave generation and decide if it will be applied based on cutoff treshold
	float Apply3DNoise(int x, int y, float Cutoff, float InstZPos);

	//function for adding instance of ISM with giver Rotation on given Position with given Ground Type of texture
	void AddInstanceAndMaterial(const FRotator& Rotation, const FVector& Position, EGroundType GroundType);

	//determine what to do with upper neighbour, when cube at i, j, k coordinates was removed
	void ManageUpperSideAfterRemoving(int i, int j, int k, const FVector& PointInCube);
	
	//determine what to do with lower neighbour, when cube at i, j, k coordinates was removed
	void ManageLowerSideAfterRemoving(int i, int j, int k, const FVector& PointInCube);

	//determine what to do with side neighbours, when cube at i, j, k coordinates was removed
	void ManageSidesAfterRemoving(int i, int j, int k, const FVector& PointInCube);

	//this function needs to be used when neighbouring chunk needs to add block, because player is adding on the end of current chunk
	void TellNeighbouringChunkToAddCube(int i, int j, const FVector& PointInside);

	//determine what to do with upper neighbour, when cube at i, j, k coordinates was added
	void ManageUpperSideAfterAdding(int i, int j, int k, const FVector& PointInCube, EGroundType ActiveGround);

	//determine what to do with lower neighbour, when cube at i, j, k coordinates was added
	void ManageLowerSideAfterAdding(int i, int j, int k, const FVector& PointInCube, EGroundType ActiveGround);

	//determine what to do with side neighbours, when cube at i, j, k coordinates was added
	void ManageSidesAfterAdding(int i, int j, int k, const FVector& PointInCube, EGroundType ActiveGround);

	//3D array representing all cubes in chunk, dimensions ChunkHalfWidth X ChunkHalfWidth X ChunkTotalHeight
	EGroundType CubeTypesArray[11][11][256];

private:
	//calculate coordinates of this chunk in arbitrary coordinates system
	void CalculateMyCoordinates();
	 
	//generate noise ibject and set parameters for noise generation
	FastNoiseLite Setup2DNoise();

	//takes as input x and y coordinates, and outputs z value based on Perlin noise
	int Generate2DNoise(int x, int y, FastNoiseLite* Noise);

	//generate types of ground in all z positions for set x and y coordinates, using Perlin noise object Noise
	void GenerateOneColumn(int x, int y, FastNoiseLite* Noise);

	//draw instances of ISM for one cube at x, y, z
	void DrawOneCube(int i, int j, int k);

	//handle drawing on upper side of one cube on i,j,k position with type GroundTypeToDraw, while the neighbouring cube type is UpperCubeType
	void DrawUpperSide(EGroundType GroundTypeToDraw, int i, int j, int k);

	//handle drawing on lower side of one cube on i,j,k position with type GroundTypeToDraw, while the neighbouring cube type is LowerCubeType
	void DrawLowerSide( EGroundType GroundTypeToDraw, int i, int j, int k);

	//handle drawing four sides of one cube on i,j,k position with type GroundTypeToDraw, while the neighbouring cubes types are stored in SideTypes array
	void DrawCubeSides(EGroundType GroundTypeToDraw, int i, int j, int k);

	//ask chunk spawner for reference for chunk on position VectorToFind, in direction OffsetDirection from PointInside, which is point inside cube at the end of the chunk on which player want to continue adding cubes
	void InteractWithNeighbourChunk(const FVector& VectorToFind, const FVector& OffsetDirection, const FVector& PointInside);

	//raytrace from pointincube to endtrace and remove hit face
	void TraceAndRemoveSide(const FVector& EndTrace, const FVector& PointInCube);

	UPROPERTY(EditAnywhere)
	UInstancedStaticMeshComponent* InstancedMesh;

	//pointer for actor managing chunk creation/removal
	UPROPERTY()
	AChunkSpawner* ChunkManager;

	//properties for noise generation
	UPROPERTY()
	int NoiseScale = 5;

	UPROPERTY(EditAnywhere)
	int Seed = 1234;

	UPROPERTY()
	float Frequency = 0.0001;

	//section for cave generation, left here for future possible implementation
	UPROPERTY()
	float CaveNoiseFrequency = 0.0001;

	UPROPERTY()
	float NoiseCutoff = 0.8;

	//section for chunk constants:

	//size of one cube of the chunk
	UPROPERTY()
	float VoxelSize = 100;

	//offset of instance plane from middle of the cube
	const int InstanceOffsetFromCubeMiddle = 50;

	//half width means (n-1)/2 where n is a number of cubes across x/y axis in chunk
	const int ChunkHalfWidth = 5;

	const int ChunkWidth = ChunkHalfWidth * 2 + 1;

	//max height for terrain generation 
	const int ChunkHeight = 70;

	//height with air cubes included - represents maximal building height
	const int ChunkTotalHeight = 256;

};
